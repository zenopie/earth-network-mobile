<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>SecretJS Bridge</title>
</head>
<body>
<script src="https://www.unpkg.com/secretjs/dist/browser.js"></script>
<script>
/*
  SecretJS Bridge for hidden Android WebView (updated to use bundled browser bundle from unpkg).

  Exposes window.runQuery(contractAddress, codeHash, queryObj, proxyUrl, lcdUrl)

  Behavior:
    - Loads SecretJS from https://www.unpkg.com/secretjs/dist/browser.js which exposes window.secretjs
    - If lcdUrl is provided, creates a readonly SecretNetworkClient and runs compute.queryContract(...)
      returning a normalized response { success: true, result: ... }
    - No proxy fallback (per request). Errors are reported back to AndroidBridge.onQueryError(...)

  Android must add a JS interface named "AndroidBridge" with methods:
    void onQueryResult(String json)
    void onQueryError(String error)
*/

(function(){
  function ensureSecretJsAvailable() {
    if (window.secretjs && window.secretjs.SecretNetworkClient) return Promise.resolve(window.secretjs);
    // If script hasn't loaded yet, poll briefly
    return new Promise((resolve, reject) => {
      let attempts = 0;
      const maxAttempts = 30; // ~3s with 100ms interval
      const iv = setInterval(() => {
        attempts++;
        if (window.secretjs && window.secretjs.SecretNetworkClient) {
          clearInterval(iv);
          resolve(window.secretjs);
        } else if (attempts >= maxAttempts) {
          clearInterval(iv);
          reject(new Error("secretjs not available after waiting"));
        }
      }, 100);
    });
  }

  async function runQueryWithSecretJs(contractAddress, codeHash, queryObj, lcdUrl) {
    // Hard-coded LCD URL per request (ignore lcdUrl parameter)
    const lcdFixed = 'https://lcd.erth.network';
    const mod = await ensureSecretJsAvailable();
    if (!mod || !mod.SecretNetworkClient) {
      throw new Error('SecretJS not available');
    }
    const SecretNetworkClient = mod.SecretNetworkClient;

    // Create readonly client pointing at provided LCD url
    const client = new SecretNetworkClient({
      url: lcdFixed,
      chainId: "secret-4", // readonly client doesn't require chainId for queries
    });

    // Build query options. secretjs compute.queryContract expects { contract_address, query, code_hash? }
    const opts = {
      contract_address: contractAddress,
      query: queryObj
    };
    if (codeHash) opts.code_hash = codeHash;

    const resp = await client.query.compute.queryContract(opts);
    return { success: true, result: resp };
  }

  async function runQuery(contractAddress, codeHash, queryObj, proxyUrl, lcdUrl) {
    try {
      // Only use SecretJS path; proxyUrl is ignored when SecretJS used.
      const res = await runQueryWithSecretJs(contractAddress, codeHash, queryObj, lcdUrl);
      console.log('runQuery result', res);
      if (window.AndroidBridge && window.AndroidBridge.onQueryResult) {
        window.AndroidBridge.onQueryResult(JSON.stringify(res));
        return;
      }
    } catch (err) {
      console.error('runQuery error', err);
      if (window.AndroidBridge && window.AndroidBridge.onQueryError) {
        window.AndroidBridge.onQueryError(String(err && err.stack ? err.stack : err));
        return;
      }
    }
  }

  // Signing + execute (broadcast) via SecretJS in WebView
  async function runExecute(contractAddress, codeHash, execMsg, mnemonic, fundsString, lcdUrl, memo) {
    try {
      // Use fixed LCD URL per project requirement (ignore lcdUrl param)
      const lcdFixed = 'https://lcd.erth.network';
      const mod = await ensureSecretJsAvailable();
      if (!mod || !mod.SecretNetworkClient || !mod.Wallet) {
        throw new Error('SecretJS not available (need SecretNetworkClient and Wallet)');
      }
      const { SecretNetworkClient, Wallet, stringToCoins } = mod;

      if (!mnemonic || !mnemonic.trim()) {
        throw new Error('Missing mnemonic for signer');
      }

      // Create signer wallet and client
      const wallet = new Wallet(mnemonic.trim());
      const walletAddress = wallet.address;

      const client = new SecretNetworkClient({
        url: lcdFixed,
        chainId: 'secret-4',
        wallet,
        walletAddress,
      });

      // Optional funds
      let funds = [];
      if (fundsString && fundsString.trim()) {
        try {
          funds = stringToCoins(fundsString.trim());
        } catch (e) {
          throw new Error('Invalid funds string: ' + e.message);
        }
      }

      const msg = {
        sender: walletAddress,
        contract_address: contractAddress,
        msg: execMsg,
        funds: funds,
      };
      if (codeHash) {
        msg.code_hash = codeHash;
      }

      // Execute with auto fee and optional memo
      console.log('runExecute sending', { contractAddress, walletAddress, msg, funds });
      const resp = await client.tx.compute.executeContract(msg, {
        gasLimit: 500_000,
        memo: memo || '',
      });
      console.log('runExecute resp', resp);

      const out = {
        success: true,
        txhash: resp?.transactionHash || resp?.txhash || null,
        height: resp?.height || null,
        rawLog: resp?.rawLog || null,
        response: resp,
      };

      if (window.AndroidBridge && window.AndroidBridge.onExecuteResult) {
        window.AndroidBridge.onExecuteResult(JSON.stringify(out));
        return;
      }
    } catch (err) {
      console.error('runExecute error', err);
      if (window.AndroidBridge && window.AndroidBridge.onExecuteError) {
        window.AndroidBridge.onExecuteError(String(err && err.stack ? err.stack : err));
        return;
      }
    }
  }

  // expose to global
  window.runQuery = runQuery;
  window.runExecute = runExecute;
})();
</script>
</body>
</html>